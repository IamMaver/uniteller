# uniteller
Есть последовательность идентификаторов, строящаяся по следующим правилам:
1. Первый идентификатор последовательности имеет вид «A1», второй — «A2», третий - «A3» и так далее. За «A9» следует «B1». Следующий после «Z9» имеет вид «A1-A1», потом «A1-A2» и так далее. После «A1-Z9» следует «A2-A1». 2. Максимальная длина идентификатора - десять групп по два символа. 3. В идентификаторах никогда не должны присутствовать буквы «D», «F», «G», «J», «M», «Q», «V» и цифра «0». Необходимо реализовать класс, обеспечивающий работу с идентификатором по заданным правилам. Класс должен обладать следующим функционалом:
   ∙ Метод, устанавливающий текущее значение идентификатора
   ∙ Метод, инкрементирующий значение идентификатора и возвращающий новое значение Технические требования к решению: 1. Код должен быть потокобезопасным.
2. Код должен компилироваться.
3. Код должен быть кроссплатформенным (успешно собираться компиляторами msvc/gcc/clang).
4. Для решения задачи разрешается использовать только стандартную библиотеку С++(стандарт до C++17 включительно).

Мои пояснения к реализации.

1. Я понимаю, что на 10 групп немного не хватит unsigned long long (требуется 71 бит при имеющихся 64х). Дело в том, что я изначально прочитал "девять групп" и спокойно сделал, а потом понял, что все чуть хуже. но 128 бит у меня под рукой нет, а логику переделывать уже не хотелось.
2. Изначально хотел использовать boost::bimap, чтоб легко сделать однозначное соответствие ключ-значение и значение-ключ, что пригодилось бы при парсинге идентификатора. Но буст запрещен, а реализовывать этот функционал через двойную анордередмапу я посчитал неизящным. 
3. Соответственно, я подозреваю, что парсинг подразумевался в "сеттере", но я подумал, что и банальное задание индекса числом сойдет.